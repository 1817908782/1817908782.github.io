<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2022/08/22/mysql-shu-ju-ku-pian/"/>
      <url>/2022/08/22/mysql-shu-ju-ku-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL数据库篇"><a href="#MySQL数据库篇" class="headerlink" title="MySQL数据库篇"></a>MySQL数据库篇</h1><h2 id="MySql有哪几种数据存储引擎-有什么区别？"><a href="#MySql有哪几种数据存储引擎-有什么区别？" class="headerlink" title="MySql有哪几种数据存储引擎?有什么区别？"></a>MySql有哪几种数据存储引擎?有什么区别？</h2><ul><li><p><strong>Mysql中通过show ENGINES指令可以看到所以支持的数据库存储引擎。最为常用的就是MyISAM和InnoDB两种。</strong></p></li><li><p><strong>MyISAM和InnoDB的区别:</strong></p><ul><li><p>存储文件。MyISAM每个表有两个文件。MYD和MYISAM文件。MYD是数据文件。MYI是索引文件。而InnoDB每个表只有一个idb文件。</p></li><li><p>InnoDB支持事务、行级锁、外键。MyISAM不支持事务、不支持外键、只支持表锁</p></li><li><p>InnoDB是聚集索引。MYISAM是非聚集索引</p></li></ul></li></ul><h2 id="什么是脏读、幻读、不可重复读？要怎么处理？"><a href="#什么是脏读、幻读、不可重复读？要怎么处理？" class="headerlink" title="什么是脏读、幻读、不可重复读？要怎么处理？"></a>什么是脏读、幻读、不可重复读？要怎么处理？</h2><ul><li><p>这些问题都是MySQL进行事务并发控制时经常遇到的问题。</p></li><li><p><strong>脏读：</strong>在事务过程中，读到了其他事务未提交的数据。</p></li><li><p><strong>不可重复读</strong>：在一个事务过程中，多次查询的结果不一致</p></li><li><p><strong>幻读</strong>：在一个事务过程中，用同样的操作查询数据，得到的记录数不相同</p></li><li><p><strong>处理的方式有很多</strong>：加锁、事务隔离、MVCC</p></li><li><p>加锁：</p><ul><li><p>脏读：在修改是加排他锁，直到事务提交才释放。读取时加共享锁，读完释放锁。‘</p></li><li><p>不可重复读：读数据时加共享锁，写数据时加排他锁。</p></li><li><p>幻读：加范围锁。</p></li></ul></li></ul><h2 id="事务的基本特性和隔离级别有哪些？"><a href="#事务的基本特性和隔离级别有哪些？" class="headerlink" title="事务的基本特性和隔离级别有哪些？"></a>事务的基本特性和隔离级别有哪些？</h2><ul><li><strong>事务</strong>：表示多个数据操作组成一个完整的事务单元，这个事务内的所以数据操作要么同时成功，要么同时失败。</li><li><strong>事务的特性：ACID</strong><ul><li><strong>原子性</strong>：在一个事务中所以操作要么同时成功，要么同时失败</li><li><strong>一致性</strong>：事务无论是成功还是失败，都必须保证事务内操作的一致，要么是操作前的数据，要么是操作后的数据。</li><li><strong>隔离性</strong>：在不同事务中操作同一个数据时，为了防止数据损坏，需要事务是互相是不可见的，互相是不受影响的</li></ul></li><li><strong>持久性</strong>：事务开始就不会终止，他的结果不受其他外在的影响，不会导致中途停止导致数据丢失。</li><li><strong>Mysql当中有五种隔离级别</strong><ul><li><strong>NINE</strong>：不使用事务。</li><li>**READ UNCOMMITED(脏读)**：允许脏读</li><li>**READ COMMITED(不可重复读)**：防止脏读，最常见的隔离级别</li><li>**REPEATABLE READ(可重复读)**：防止脏读和不可重复读，MYSQL默认的</li></ul></li><li><strong>SERIALIZABLE</strong>：事务串行，可以防止脏读、幻读、不可重复读。</li><li><strong>五种隔离级别，级别越高，事务的安全性是更高的，但是，事务的并发性能也就会越低。</strong></li></ul><h2 id="MySql锁有哪些？什么是间隙锁？"><a href="#MySql锁有哪些？什么是间隙锁？" class="headerlink" title="MySql锁有哪些？什么是间隙锁？"></a>MySql锁有哪些？什么是间隙锁？</h2><ul><li><p><strong>从锁的粒度来区分</strong></p><ul><li><p><strong>行锁</strong>：加锁粒度小，但是加锁资源开销比较大。InnoDB支持</p><ul><li><strong>共享锁</strong>：读锁。多个事务可以对同一个数据共享同一把锁。持有所的事务都可以访问数据，但是只能加读锁不能写。</li><li><strong>排他锁</strong>：写锁。只有一个事务能够获的排他锁，其他事务都不能获取该行的锁，其他事务不能加读锁也不能加写锁，但是是可以读(select)到的。InnoDB会对update\delete\insert语句自动添加排他锁。</li></ul></li><li><p><strong>自增锁</strong>：通常是针对MySql当中的自增字段+1。如果有事务回滚这种情况，数据会回滚，但是自增序列不会回滚。</p></li><li><p><strong>表锁</strong>：加锁粒度大，加锁资源开销比较小。InnoDB和MyISAM都支持。</p><ul><li><strong>表共享读锁：</strong></li><li><strong>表排他写锁：</strong></li></ul></li><li><p><strong>意向锁</strong>：是InnoDB自动添加的一种锁，不需要用户干预。</p></li><li><p><strong>全局锁</strong>：加锁之后整个数据库实例都处于只读状态。所以的数据变更操作都会被挂起。一般用于全库备份的时候。</p></li><li><p><strong>乐观锁</strong>：并不会真正的去锁某行记录，而是通过一个版本号实现的（先去用一下，看版本号对不对，如果不对就是别人在用）</p></li><li><p><strong>悲观锁</strong>：行锁、表锁都是悲观锁(不管别人用用不用都加上锁)</p></li></ul></li><li><p><strong>常见的锁算法：</strong></p><ul><li><strong>记录锁</strong>：锁一条具体的数据。</li><li><strong>间隙锁</strong>：RR隔离级别下会加间隙锁。锁一定的范围，而不是锁具体的记录。是为了防止产生幻读。</li><li><strong>Next-key</strong>：间隙锁+右记录锁。</li></ul></li></ul><h2 id="MySql的索引结构是什么样的？聚集索引和非聚集索引又是什么？"><a href="#MySql的索引结构是什么样的？聚集索引和非聚集索引又是什么？" class="headerlink" title="MySql的索引结构是什么样的？聚集索引和非聚集索引又是什么？"></a>MySql的索引结构是什么样的？聚集索引和非聚集索引又是什么？</h2><ul><li><p><strong>B+树：</strong></p><ul><li>非叶子节点不存储数据，只进行数据索引</li><li>所以数据都存储在叶子节点当中</li><li>每个叶子节点都存有相邻叶子节点的指针</li><li>叶子节点按照本身关键字从小到大排序。</li></ul></li><li><p><strong>聚集索引</strong>：聚集索引就是数据和索引是在一起的，也是防止回表，但是维护也是更重的</p></li><li><p>MyISAM使用的是非聚集索引，树的子节点的data不是数据的本身，而是数据存放的地址。InnoDB采用的是聚集索引，树的叶子节点上的data是数据的本身。</p></li><li><p>聚簇索引的数据物理存放顺序和索引顺序是一致的，所以一个表当中只能有一个聚簇索引，而非聚簇索引可以有多个。</p></li><li><p>InnoDB中，如果表定义了PK，那PK就是聚簇索引。如果没有PK，就会找第一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。</p></li><li><p><strong>MySQL的覆盖索引和回表</strong></p><ul><li>如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不需要再回表查询，这样查询速度就可以更快。</li><li>实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引当中。</li></ul></li></ul><h2 id="MySql的集群是如何搭建的？读写分离是怎么做的？"><a href="#MySql的集群是如何搭建的？读写分离是怎么做的？" class="headerlink" title="MySql的集群是如何搭建的？读写分离是怎么做的？"></a>MySql的集群是如何搭建的？读写分离是怎么做的？</h2><ul><li><img src="/2022/08/22/mysql-shu-ju-ku-pian/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.png"></li><li><strong>Mysql的主从复制中主要有三个线程</strong>：master(binlog dump)、slave(I/O thread、SQL thread)，<strong>Master一条线程和Slave两条线程</strong><ul><li>主节点binlog，主从复制的基础是主库记录数据库的所以变更记录到binlog。binlog是数据库服务器启动的那一刻，保存所以修改数据库结构或内容的一个文件。</li><li>主节点log dump线程，当binlog有变动时，log dump线程读取其内容并发送给从节点</li><li>从节点I/O线程接收binlog内容，并将其写入relay log文件中</li></ul></li><li>从节点的SQL线程读取relay log文件内容对数据更新进行重放，最终保证主从数据库的一致性。</li><li>MySQL的主从集群只会将binlog从主节点同步到从节点，而不会反过来同步。由此也就引申了读写分离的问题。因为要保证主从之间的数据一致，写数据的操作只能在主节点完成。</li></ul><h2 id="谈谈如何对MySql进行分库分表？多大数据量需要分库分表？分库分表的方式和分片策略有哪些？分库分表后，SQL语句的执行流程是怎样的？"><a href="#谈谈如何对MySql进行分库分表？多大数据量需要分库分表？分库分表的方式和分片策略有哪些？分库分表后，SQL语句的执行流程是怎样的？" class="headerlink" title="谈谈如何对MySql进行分库分表？多大数据量需要分库分表？分库分表的方式和分片策略有哪些？分库分表后，SQL语句的执行流程是怎样的？"></a>谈谈如何对MySql进行分库分表？多大数据量需要分库分表？分库分表的方式和分片策略有哪些？分库分表后，SQL语句的执行流程是怎样的？</h2><ul><li><p>什么是分库分表？就是当表中的数据量过大时，整个查询效率就会降低的很明显。这时为了提升查询效率，就要将一个表中的数据分散到多个数据库的多个表当中。</p></li><li><p>分库分表的方式有垂直分片和水平分片。垂直分片就是从业务角度将不同的表拆分到不同的库中，能够解决数据库文件过大的问题，但是还是不能解决查询效率的问题。水平分片就是从数据角度将一个表中的数据拆分到不同的库或表中，这样可以从根本上解决查询效率低的问题。</p></li><li><p>常用的分片策略：</p><ul><li>取余/取模：优点 均匀存放数据库，缺点 扩展非常麻烦。如果十万条数据按取模划分为2个库的话就是一边五万，假如需要加一个库的话就需要重新划分。</li><li>按范围分片：比较好扩展，数据分布不够均匀</li><li>按时间分片：比较容易将热点的数据区分出来</li><li>按枚举值分片：例如按地区分片</li><li>按照目标字段前缀指定进行分区:自定义业务规则分片</li></ul></li><li><p>水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。</p></li><li><p>阿里提供的开发手册中，建议：一个表数据量超过500万或者数据文件超哥2G，就要考虑分库分表了(设计表之前就要分析3年内的数据时否会达到500万)</p></li><li><p>分库分表最常用的组件：Mycat\ShardingSphere</p></li><li><p>分库分表的问题：跨库查询、跨库排序、分布式事务、公共表、主键重复。。。。</p></li></ul><h2 id="MySql数据库中，什么情况下设置了索引但是无法使用？"><a href="#MySql数据库中，什么情况下设置了索引但是无法使用？" class="headerlink" title="MySql数据库中，什么情况下设置了索引但是无法使用？"></a>MySql数据库中，什么情况下设置了索引但是无法使用？</h2><ul><li>没有符合最左前缀原则</li><li>字段进行了隐式数据类型转换</li><li>走索引没有全表扫描效率高</li></ul><h2 id="B树和B-树的区别，为什么Mysql使用B-树"><a href="#B树和B-树的区别，为什么Mysql使用B-树" class="headerlink" title="B树和B+树的区别，为什么Mysql使用B+树"></a>B树和B+树的区别，为什么Mysql使用B+树</h2><ul><li><p><strong>B树的特点：</strong></p><ul><li>节点排序</li><li>一个节点可以存放多个元素，多个元素也排序了</li></ul></li><li><p><strong>B+树的特点</strong></p><ul><li>拥有B树的特点</li><li>叶子节点之间有指针</li><li>非叶子节点上的元素在叶子节点上都冗余了，也就是叶子节点中存储了所以的元素，并且排好顺序</li></ul></li><li><p>Mysql索引使用的是B+树，因为索引是用来加快查询的，而B+树通过对数据进行排序所以是可以提高查询速度的，然后通过一个节点中可以存储多个元素，从而可以使得B +树的高度不会太高，在Mysq中一个nnocdb页就是一个8+树节点，一个nmnodb页默认16kb，所以一般情况下一颗两层的B+树可以存200万行左右的数据，然后通过利用B+树叶子节点存储了所有数据并且进行了排序，并且叶子节点之间有指针，可以很好的支持全表扫描，范围查找等sQL语句。</p></li></ul><h2 id="Mysql慢查询怎么优化？"><a href="#Mysql慢查询怎么优化？" class="headerlink" title="Mysql慢查询怎么优化？"></a>Mysql慢查询怎么优化？</h2><ul><li>检查是否使用了索引，如果没有使用索引则可以建立一个索引</li><li>检查所利用的索引是否是最优的索引</li><li>检查所查询的字段是否是必须的，是否查询了过多的字段，查出了多余的数据</li><li>检查表中的数据是否过多，是否需要进行分库分表了</li><li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当的增加资源(内存、cpu、带宽)</li><li></li></ul><h2 id="索引的几种类型？"><a href="#索引的几种类型？" class="headerlink" title="索引的几种类型？"></a>索引的几种类型？</h2><ul><li><strong>普通索引</strong>：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 <code>ALTER TABLE table_name ADD INDEX index_name (column)</code> 创建；</li><li><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。通过 <code>ALTER TABLE table_name ADD UNIQUE index_name (column)</code> 创建；</li><li><strong>主键索引</strong>：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；</li><li><strong>组合索引</strong>：组合表中多个字段创建的索引，遵守最左前缀匹配规则；</li><li><strong>全文索引</strong>：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li></ul><h2 id="什么是存储过程？"><a href="#什么是存储过程？" class="headerlink" title="什么是存储过程？"></a>什么是存储过程？</h2><ul><li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li></ul><h2 id="MySQL-中有哪些常见日志？"><a href="#MySQL-中有哪些常见日志？" class="headerlink" title="MySQL 中有哪些常见日志？"></a>MySQL 中有哪些常见日志？</h2><ul><li><p><strong>重做日志（redo log）</strong>：物理日志</p><ul><li><strong>作用是确保事务的持久性。</strong> redo 日志记录事务执行后的状态，用来恢复未写入 data file 的已提交事务数据。</li></ul></li><li><p><strong>回滚日志（undo log）</strong>：逻辑日志</p><ul><li><strong>作用是保证数据的原子性。</strong> 保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。</li></ul></li><li><p><strong>二进制日志（binlog）</strong>：逻辑日志</p><ul><li>常用于主从同步或数据同步中，也可用于数据库基于时间点的还原。</li></ul></li><li><p><strong>错误日志（errorlog）</strong></p><ul><li>记录着 MySQL 启动和停止，以及服务器在运行过程中发生的错误的相关信息。在默认情况下，系统记录错误日志的功能是关闭的，错误信息被输出到标准错误输出。</li></ul></li><li><p><strong>慢查询日志（slow query log）</strong></p><ul><li>记录执行时间过长和没有使用索引的查询语句（<strong>默认 10s</strong>），同时只会记录执行成功的语句。</li></ul></li></ul><h2 id="Mysql中ACID靠什么保证的？"><a href="#Mysql中ACID靠什么保证的？" class="headerlink" title="Mysql中ACID靠什么保证的？"></a>Mysql中ACID靠什么保证的？</h2><ul><li><strong>原子性</strong>：由undo_log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql</li><li><strong>一致性</strong>：由其他三大特性保证，程序代码要保证业务的一致性</li><li><strong>隔离性</strong>：由MVCC来保证</li><li><strong>持久性</strong>：由内存+redo_log来保证，mysql修改数据同时在内存和redo_log记录这次操作，宕机的时候可以从redo_log恢复(redo_log相当于binlog日志，记录的都是数据库的数据)</li></ul><h1 id="Resis缓存篇"><a href="#Resis缓存篇" class="headerlink" title="Resis缓存篇"></a>Resis缓存篇</h1><h2 id="Redis是单线程还是多线程"><a href="#Redis是单线程还是多线程" class="headerlink" title="Redis是单线程还是多线程"></a>Redis是单线程还是多线程</h2><ul><li>Redis 6.0版本之前的单线程指的是其网络I/O和键值对读写是由一个线程完成的</li><li>Redis 6.0引入了多线程指的是网络请求过程中采用了多线程,而键值对读写命令仍然采用的是单线程处理的，所以Redis依然是并发安全的。</li><li>也就是只有网络请求模块和数据操作模块是单线程，而其他的持久化、集群同步等，其实是由额外的线程执行的。</li></ul><h2 id="Redis单线程为什么还能那么快？"><a href="#Redis单线程为什么还能那么快？" class="headerlink" title="Redis单线程为什么还能那么快？"></a>Redis单线程为什么还能那么快？</h2><ul><li>命令执行基于内存操作，一条命令在内存里操作的时间是几十纳秒</li><li>命令执行是单线程操作，没有线程切换开销</li><li>基于IO多路复用机制提升Redis的I/O利用率</li><li>高效的数据存储结构：全局hash表以及多种高效数据结构，比如：跳表，压缩列，链表等等</li></ul><h2 id="Redis过期了为什么内存没释放"><a href="#Redis过期了为什么内存没释放" class="headerlink" title="Redis过期了为什么内存没释放"></a>Redis过期了为什么内存没释放</h2><ul><li><strong>Redis对于过期的key的处理一般有惰性删除和定时删除两种策略</strong><ul><li><strong>惰性删除</strong>：当读/写一个已经过期的key时，会触发惰性删除策略，判断key是否已过期，如果过期了直接删除这个key</li><li><strong>定时删除</strong>：由于惰性删除策略无法保证冷数据被及时删除，所以会定期(默认每100ms)主动淘汰一批已过期的key，这里的一批只是部分过期的key，所以可能会导致出现部分key已经过期但是还没清理掉的情况，导致内存没有释放。</li></ul></li></ul><h2 id="Redis-key没设置过期时间为什么被redis主动删除了"><a href="#Redis-key没设置过期时间为什么被redis主动删除了" class="headerlink" title="Redis key没设置过期时间为什么被redis主动删除了"></a>Redis key没设置过期时间为什么被redis主动删除了</h2><ul><li><p>当redis已用内存超过maxmemory限定时，触动主动清理策略</p></li><li><p><strong>主动清理策略在redis 4.0之前一共实现了种内存策略，4.0之后，又增加了2种策略，总共8总:</strong></p></li><li><p><strong>针对设置了过期时间的key做处理</strong></p><ul><li><p>**volatile-ttl:**在筛选时，会针对设置了过期时间的键值对，根据过期时间 的先后进行删除，越早过期的越先被删除。</p></li><li><p><strong>volatile-random</strong>：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除</p></li><li><p><strong>volatile-lru</strong>:会使用LRU算法筛选设置了过期时间的键值对删除</p></li><li><p><strong>volatile-lfu</strong>:会使用LFU算法筛选设置了过期时间的键值对删除</p></li><li><p><strong>针对所有的key做处理</strong></p></li><li><p>**allkeys-random:**从所有键值对中随机选择并删除数据。</p><ul><li><strong>allkeys-lru</strong>:会使用LRU算法筛选所以数据的键值对删除</li><li>**allkeys-lfu:**会使用LFU算法筛选所以数据的键值对删除</li></ul></li><li><p>不处理：</p></li><li><p>noeviction:8:不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed whenused memory”，此时Redis只响应读操作。</p></li></ul></li></ul><h2 id="Redis淘汰Key的算法LRU与LFU区别"><a href="#Redis淘汰Key的算法LRU与LFU区别" class="headerlink" title="Redis淘汰Key的算法LRU与LFU区别"></a>Redis淘汰Key的算法LRU与LFU区别</h2><ul><li><strong>LRU算法(Least Recently Used，最近最少使用):淘汰很久没被访问过的数据，以最近一次访问时间作为参考</strong></li><li><strong>LFU算法(Least Frequently Used，最不经常使用):淘汰最近一段时间被访问次数最少的数据，以次数作为参考</strong></li><li>绝大多数情况我们都可以用LRU策略，当存在大量的热点缓存数据时，LFU可能更好点</li></ul><h2 id="Redis主从、哨兵、集群架构优缺点比较"><a href="#Redis主从、哨兵、集群架构优缺点比较" class="headerlink" title="Redis主从、哨兵、集群架构优缺点比较"></a>Redis主从、哨兵、集群架构优缺点比较</h2><ul><li><p><strong>主从模式</strong></p><ul><li><img src="/2022/08/22/mysql-shu-ju-ku-pian/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png"></li></ul></li><li><p>主从模式是一个主节点对外提供服务，从节点的数据与主节点的数据时一致的，当主节点挂掉了之后，从节点会变成主节点，但是这个切换的过程需要运维人员操作</p></li><li><p><strong>哨兵模式</strong></p><ul><li><p><img src="/2022/08/22/mysql-shu-ju-ku-pian/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png"></p></li><li><p>在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略微复杂，并且性能和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率</p></li></ul></li><li><p><strong>集群模式</strong></p><ul><li><img src="/2022/08/22/mysql-shu-ju-ku-pian/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F.png"></li><li><strong>redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制、高可用和分片特性。Redis集群不需要sentine哨兵·也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可水平扩展，据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单。</strong></li></ul></li></ul><h2 id="Redis集群数据hash分片算法是怎么回事"><a href="#Redis集群数据hash分片算法是怎么回事" class="headerlink" title="Redis集群数据hash分片算法是怎么回事"></a>Redis集群数据hash分片算法是怎么回事</h2><ul><li>Redis Cluster将所有数据划分为16384个slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。</li><li>当Redis Cluster的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key时，可以根据槽位定位算法定位到目标节点。</li><li>Cluster默认会对 key值使用crc16算法进行hash得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位。再根据槽位值和Redis节点的对应关系就可以定位到key具体是落在哪个Redis节点上的。</li></ul><h2 id="Redis主从切换导致缓存雪崩"><a href="#Redis主从切换导致缓存雪崩" class="headerlink" title="Redis主从切换导致缓存雪崩"></a>Redis主从切换导致缓存雪崩</h2><ul><li><p>我们假设,slave的机器时钟比 master走得快很多。此时，Redis master里设置了过期时间的key，从 slave角度来看，可能会有很多在master里没过期的数据其实已经过期了。<br>如果此时操作主从切换，把 slave提升为新的 master。<br>它成为master后，就会开始大量清理过期key，此时就会导致以下结果:</p><ul><li>master大量清理过期key，主线程可能会发生阻塞，无法及时处理客户端请求。</li><li>Redis 中数据大量过期，引发缓存雪崩。</li></ul></li><li><p><strong>当master与slave机器时钟严重不一致时。对业务的影响非常大。所以，我们一定要保证主从库的机器时钟—致性，避免发生这些问题。</strong></p></li></ul><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><ul><li><p><strong>RDB：</strong></p><ul><li>在默认情况下，Redis 将内存数据库快照保存在名字为dump.rdb的二进制文件中。</li><li>你可以对Redis进行设置，让它在”N秒内数据集至少有M个改动”这一条件被满足时，自动保存一次数据</li><li>比如说，以下设置会让Redis在满足” 60秒内有至少有1000个键被改动”这一条件时，自动保存一次数据</li><li>save 60 1000l关闭RDB只需要将所有的save保存策略注释掉即可</li><li>还可以手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。</li><li>bgsave的写时复制(cOW)机制：<ul><li>Redis借助操作系统提供的写时复制技术(Copy-On-Write,COW)，在生成快照的同时，依然可以正常处理写命令。简单来说，<br>bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它们写入RDB文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和bgsave子进程相互不影响。但是，如果主线程要修改一块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</li></ul></li></ul></li><li><p><strong>AOF:</strong></p><ul><li>快照功能并不是非常耐久（durable): 如果Redis因为某些原因而造成故障停机，那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从1.1版本开始，Redis增加了一种完全耐久的持久化方式: AOF持久化，将修改的每一条指令记录进文件<br>appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)</li><li>从现在开始，每当Redis 执行一个改变数据集的命令时（比如SET)，这个命令就会被追加到AOF文件的末尾。这样的话，当Redis重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。你可以配置Redis多久才将数据fsync到磁盘—次。<ul><li>appendfsync always:每次有新命令追加到 AOF文件时就执行一次 fsync ,非常慢，也非常安全。</li><li>appendfsync everysec:每秒 fsync一次，足够快，并且在故障时只会丢失1秒钟的数据。</li><li>appendfsync no:从不fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。</li></ul></li></ul></li><li><p><strong>AOF重写：</strong></p><ul><li>AOF文件里可能有太多没用指令，所以AOF会定期根据内存的最新数据生成aof文件</li><li>AOF重写redis会fork出一个子进程去做(与bgsave命令类似)，不会对redis正常命令处理有太多影响</li></ul></li></ul><h2 id="Redis线上数据如何备份"><a href="#Redis线上数据如何备份" class="headerlink" title="Redis线上数据如何备份"></a>Redis线上数据如何备份</h2><ul><li>写crontab定时调度脚本，每小时都copy一份rdb或aof文件到另一台机器上去，保存最近48小时的备份</li><li>每天都保留一份当日的数据备份到一个目录中去，可以保留最近1个月的备份</li><li>每次copy备份的时候，都把太旧的备份给删了</li></ul><h2 id="Redis复制风暴是怎么回事"><a href="#Redis复制风暴是怎么回事" class="headerlink" title="Redis复制风暴是怎么回事"></a>Redis复制风暴是怎么回事</h2><ul><li><p>如果redis主节点有很多从节点，在某一时刻如果所有都同时连接主节点，那么主节点会同时把内存快照RDB发送多个从节点，这样会导致Redis主节点压力非常大，这就是所谓的Redis复制风暴问题。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2></li></ul><h2 id="Redis集群网络抖动导致频繁主从切换怎么处理"><a href="#Redis集群网络抖动导致频繁主从切换怎么处理" class="headerlink" title="Redis集群网络抖动导致频繁主从切换怎么处理"></a>Redis集群网络抖动导致频繁主从切换怎么处理</h2><ul><li>真实世界的机房网络往往并不是风平浪静的，它们经常发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后又很快就恢复。</li><li>为了解决这个问题，Redis Cluster提供了一种选项cluster-node-timout,表示当某个节点持续timeout的时间失联时，才可以认为该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换</li></ul><h2 id="Redis集群为什么至少需要三个master节点"><a href="#Redis集群为什么至少需要三个master节点" class="headerlink" title="Redis集群为什么至少需要三个master节点"></a>Redis集群为什么至少需要三个master节点</h2><ul><li>因为新master的选举需要大半数的master节点同意才能选举成功，如果只有两个master节点，当其中一个m挂了，是达不到选举新master的条件的。</li></ul><h2 id="Redis和Mysql如何保证数据的一致"><a href="#Redis和Mysql如何保证数据的一致" class="headerlink" title="Redis和Mysql如何保证数据的一致"></a>Redis和Mysql如何保证数据的一致</h2><ul><li>先更新Mysql，在更新Redis，如果Redis更新失败，可能仍不一致</li><li>先删除Redis缓存数据，在更新Mysql数据，再次查询的时候在将数据添加到缓存中，这种方案能解决方案1的问题，但是在高并发下性能较低，而且仍然会出现数据不一致的问题，比如线程1删除了redis缓存，正在更新mysql，此时另外一个查询在查询，那么就会把Mysql的老数据有查到redis中。</li><li><strong>延时双删，步骤是：先删除Resis缓存数据，再更新Mysql，延时几百毫秒再删除Redis缓存数据，这样就算在更新Mysql时有其他线程读了Mysql，把老的数据读到了Resis中，那么也会被删除，从而达到数据一致。</strong></li></ul><h2 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h2><ul><li><p><strong>主从：</strong></p></li><li><p><strong>哨兵模式：</strong></p><p>sentinel，哨兵是redis 集群中非常重要的一个组件，主要有以下功能:</p><ul><li><strong>集群监控</strong>:负责监控redis master和 slave进程是否正常工作。</li><li><strong>消息通知</strong>:如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li><strong>故障转移</strong>:如果master node挂掉了，会自动转移到slave node上。</li><li><strong>配置中心</strong>:如果故障转移发生了，通知client客户端新的 master 地址。</li></ul><p>哨兵用于实现redis.集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。</p><ul><li>故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的</li><li>哨兵通常需要3个实例，来保证自己的健壮性。</li><li>哨兵+ redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</li><li>对于哨兵+ redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</li></ul></li><li><p><strong>Redis Cluster（redis集群）</strong></p><ul><li><p>Redis Cluster是一种服务端Sharding技术，3.0版本开始正式提供。采用slot(槽)的概念。一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行</p></li><li><p>方案说明:</p><ul><li>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽(哈希值)区间的数据，默认分配了16384个糟位</li><li>每份数据分片会存储在多个互为主从的多节点上</li><li>数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)</li><li>同一分片多个节点间的数据不保持强一致性</li><li>读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点</li><li>扩容时需要需要把旧节点的数据迁移一部分到新节点</li></ul></li><li><p><strong>优点：</strong></p><ul><li>无中心架构,支持动态扩容，对业务透明</li><li>具备Sentinel的监控和自动Failover(故障转移)能力</li><li>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可</li><li>高性能，客户端直连redis服务，免去了proxy代理的损耗</li></ul></li><li><p><strong>缺点</strong></p><ul><li>·运维也很复杂，数据迁移需要人工干预</li><li>只能使用0号数据库</li><li>不支持批量操作(pipeline管道操作）</li><li>分布式逻辑和存储模块耦合等</li></ul></li></ul></li></ul><h2 id="Redis的数据结构及使用场景"><a href="#Redis的数据结构及使用场景" class="headerlink" title="Redis的数据结构及使用场景"></a>Redis的数据结构及使用场景</h2><ul><li>Redis的数据结构有：<ul><li>字符串：可以用来做最简单的数据缓存，可以缓存某个简单的字符串，也可以存储某个json格式的字符串，redis分布式锁的实现就是利用了这种数据结构，还包括可以实现计数器、session共享、分布式ID</li><li>哈希表：可以存储一些key-value对，更适合用来存储对象</li><li>列表：redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使用，可以用来缓存类似公众号、微博等消息流数据</li><li>集合：和列表类似，也可以存储多个元素，但是不可以重复，集合可以进行交集、并集、差集操作，从而可以实现类似，我和某人共同关注的人，朋友圈点赞的功能</li><li>有序集合：集合是无序的，有序集合可以设置顺序，可以用来实现排行榜</li></ul></li></ul><h2 id="布隆过滤器原理，优缺点"><a href="#布隆过滤器原理，优缺点" class="headerlink" title="布隆过滤器原理，优缺点"></a>布隆过滤器原理，优缺点</h2><ul><li><p>位图: int[10]，每个int类型的整数是4*8=32个bit，则lint[10]一共有320 bit，每个bit非0即1，初始化时都是0<br>添加数据时，将数据进行hash得到hash值，对应到bit位，将该bit改为1，hash函数可以定义多个，则一个数据添加会将多个(hash函数个数) bit改为1，多个hash函数的目的是减少hash碰撞的概率<br>查询数据: hash函数计算得到hash值，对应到bit中，如果有一个为0，则说明数据不在bit中，如果都为1，则该数据可能在bit中</p></li><li><p>优点：</p><ul><li>占用内存小</li><li>增加和查询元素的时间复杂度为:O(K),(K为哈希函数的个数，一般比较小)，与数据量大小无关</li><li>哈希函数相互之间没有关系，方便硬件并进运算</li><li>不需要存储元素本身，在某些对保密要求比较严格的场合有很大优势</li><li>数据量很大时，布隆过滤器可以表示全集</li><li>使用同一组散列函数的布隆过滤器可以进行交、并、差运算</li></ul></li><li><p>缺点：</p><ul><li>误判率，不能准确判断元素是否存在集合中</li><li>不能获取元素本身</li><li>一般情况下不能删除元素</li></ul></li></ul><h2 id="什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？"><a href="#什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？" class="headerlink" title="什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？"></a>什么是缓存穿透？缓存击穿？缓存雪崩？怎么解决？</h2><ul><li><p>缓存穿透：缓存查不到数据，数据库也查不到数据</p></li><li><p>解决方案：</p><ul><li>对参数进行合法性效应</li><li>将数据库没有查询到也存储到redis中。这时需要注意为了防止redis没无用的数据占满，需要设置一个较短的过期时间</li><li>引入布隆过滤器，在访问之前对数据进行判断是否存在这样的数据，不存在则过滤。要注意布隆过滤器有一定的误判几率，并且布隆过滤器只能加数据而对于减数据就相当的麻烦</li></ul></li><li><p>缓存击穿：缓存查不到数据，而数据库中有数据。一般是出现在数据初始化以及缓存中有大量数据同时过期，如果有过多的请求就会导致查询时全部都打到数据库，数据库造成压力</p></li><li><p>解决方案：</p><ul><li>设置热点数据永不过期，这时要注意在value上设置一个逻辑过期时间，然后另外起一个线程，定期重建这些缓存</li><li>加载DB的时候，要注意并发</li><li>可以使用双重检查锁，当出现并发可以加双重检查锁，让线程一个一个执行，只要有一个执行后就会存入redis，后面的查询就不会打到DB上了</li></ul></li><li><p>缓存雪崩：缓存大面积过期，导致请求打到DB上</p></li><li><p>解决方案：</p><ul><li>把key的过期时间设置为不同的，在原先过期时间的基础上设置一个随机数，把失效时间分散开来</li></ul></li></ul><h2 id="简述redis的数据9种数据类型"><a href="#简述redis的数据9种数据类型" class="headerlink" title="简述redis的数据9种数据类型"></a>简述redis的数据9种数据类型</h2><ul><li>String：字符串</li><li>Lsit：列表</li><li>Hash：哈希表</li><li>Set：无序集合</li><li>Sorted Sert:有序集合</li><li>bitmap：布隆过滤器</li><li>GeoHash:坐标，借助Sorted Set实现，通过zset的score进行排序就可以得到坐标附近的其它元素，通过将score还原成坐标值就可以得到元素的原始坐标</li><li>HyperLogLog：统计不重复数据,用于大数据基数统计</li><li>Streams：内存版的kafka</li></ul><h1 id="葵花宝典"><a href="#葵花宝典" class="headerlink" title="葵花宝典"></a>葵花宝典</h1><ul><li><a href="https://blog.csdn.net/ThinkWon/article/details/104588551?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166132499216782425184685%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166132499216782425184685&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-104588551-null-null.142%5Ev42%5Econtrol,185%5Ev2%5Econtrol&amp;utm_term=java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98&amp;spm=1018.2226.3001.4187">葵花宝典</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc</title>
      <link href="/2022/05/16/springmvc/"/>
      <url>/2022/05/16/springmvc/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC框架介绍"><a href="#SpringMVC框架介绍" class="headerlink" title="SpringMVC框架介绍"></a>SpringMVC框架介绍</h1><h2 id="这里对SpringMVC框架进行一个简单的介绍"><a href="#这里对SpringMVC框架进行一个简单的介绍" class="headerlink" title="这里对SpringMVC框架进行一个简单的介绍"></a>这里对SpringMVC框架进行一个简单的介绍</h2><ul><li>springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。</li><li>springmvc是一个基于mvc的web框架。</li><li>springmvc 表现层：方便前后端数据的传输</li><li>Spring MVC 拥有控制器，作用跟Struts类似，接收外部请求，解析参数传给服务层</li><li>MVC是指，C控制层，M模块层，V显示层这样的设计理念，而SSM框架里面SPRING MVC本身就是MVC框架，<br>作用是帮助（某种意义上也可以 理解为约束）我们要按照MVC这样的设计来开发WEB项目，而另外两个框架spring主要是用作IOC,AOP等其他的一些设计原则，至于mybatis是用来方便操作数据库的，所以他们都在MV里面，至于V指的是展示部分，一般是指JSP，freemarks这种前提其实，和SSM就没有太大的关系了</li></ul><h2 id="springmvc项目架构图"><a href="#springmvc项目架构图" class="headerlink" title="springmvc项目架构图"></a>springmvc项目架构图</h2><p><img src="/2022/05/16/springmvc/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="springmvc项目架构图"></p><h2 id="Springmvc架构原理解析"><a href="#Springmvc架构原理解析" class="headerlink" title="Springmvc架构原理解析"></a>Springmvc架构原理解析</h2><ul><li><p>发起请求到前端控制器(DispatcherServlet)</p></li><li><p> 前端控制器请求HandlerMapping查找 Handler，可以根据xml配置、注解进行查找</p></li><li><p> 处理器映射器HandlerMapping向前端控制器返回Handler</p></li><li><p> 前端控制器调用处理器适配器去执行Handler</p></li><li><p> 处理器适配器去执行Handler</p></li><li><p> Handler执行完成给适配器返回ModelAndView</p></li><li><p> 处理器适配器向前端控制器返回ModelAndView，ModelAndView是springmvc框架的一个底层对象，包括 Model和view</p></li><li><p> 前端控制器请求视图解析器去进行视图解析，根据逻辑视图名解析成真正的视图(jsp)</p></li><li><p> 视图解析器向前端控制器返回View</p></li><li><p> 前端控制器进行视图渲染，视图渲染将模型数据(在ModelAndView对象中)填充到request域</p></li><li><p> 前端控制器向用户响应结果</p><h3 id="组件："><a href="#组件：" class="headerlink" title="组件："></a>组件：</h3></li><li><p>前端控制器DispatcherServlet（不需要程序员开发）<br>作用接收请求，响应结果，相当于转发器，中央处理器。<br>有了DispatcherServlet减少了其它组件之间的耦合度。</p></li><li><p>处理器映射器HandlerMapping(不需要程序员开发)<br>作用：根据请求的url查找Handler</p></li><li><p>处理器适配器HandlerAdapter<br>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler</p></li><li><p>处理器Handler(需要程序员开发)<br>注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler</p></li><li><p>视图解析器View resolver(不需要程序员开发)<br>作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）</p></li><li><p>视图View(需要程序员开发jsp)<br>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）</p></li></ul><h2 id="mvc基础配置文件："><a href="#mvc基础配置文件：" class="headerlink" title="mvc基础配置文件："></a>mvc基础配置文件：</h2><ul><li><p>web.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token comment">&lt;!--configure the setting of springmvcDispatcherServlet and configure the mapping--&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>springmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">&gt;</span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">&gt;</span></span>contextConfigLocation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">&gt;</span></span>classpath:springmvc-servlet.xml<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">&gt;</span></span>springmvc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">&gt;</span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>springmvc-servlet.xml</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span> <span class="token attr-name">xmlns</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>context</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/context<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xmlns:</span>mvc</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/mvc<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">xsi:</span>schemaLocation</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd        http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.1.xsd<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                        <span class="token comment">&lt;!-- scan the package and the sub package --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>component-scan</span> <span class="token attr-name">base-package</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>test.SpringMVC<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- don't handle the static resource --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>default-servlet-handler</span> <span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- if you use annotation you must configure following setting --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>annotation-driven</span> <span class="token punctuation">/&gt;</span></span>        <span class="token comment">&lt;!-- configure the InternalResourceViewResolver --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>org.springframework.web.servlet.view.InternalResourceViewResolver<span class="token punctuation">"</span></span>             <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>internalResourceViewResolver<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token comment">&lt;!-- 前缀 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>prefix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/WEB-INF/jsp/<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>        <span class="token comment">&lt;!-- 后缀 --&gt;</span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>suffix<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>.jsp<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="SpringMVC常用注解"><a href="#SpringMVC常用注解" class="headerlink" title="SpringMVC常用注解"></a>SpringMVC常用注解</h2><ul><li>@Controller<br> 　　 负责注册一个bean 到spring 上下文中</li><li>@RequestMapping<br> 　　 注解为控制器指定可以处理哪些 URL 请求</li><li>@RequestBody<br> 　　 该注解用于读取Request请求的body部分数据，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上 ,再把HttpMessageConverter返回的对象数据绑定到 controller中方法的参数上</li><li>@ResponseBody<br> 　　 该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区</li><li>@ModelAttribute 　　　<br> 　　在方法定义上使用 @ModelAttribute 注解：Spring MVC 在调用目标处理方法前，会先逐个调用在方法级上标注了@ModelAttribute 的方法<br> 　　<br> 　　在方法的入参前使用 @ModelAttribute 注解：可以从隐含对象中获取隐含的模型数据中获取对象，再将请求参数 –绑定到对象中，再传入入参将方法入参对象添加到模型中</li><li>@RequestParam　<br> 　　在处理方法入参处使用 @RequestParam 可以把请求参 数传递给请求方法</li><li>@PathVariable<br> 　　绑定 URL 占位符到入参 　</li><li>@ExceptionHandler<br> 　　注解到方法上，出现异常时会执行该方法</li><li>@ControllerAdvice<br> 　　使一个Contoller成为全局的异常处理类，类中用@ExceptionHandler方法注解的方法可以处理所有Controller发生的异常</li></ul><h2 id="SpringMVC详细运行流程图"><a href="#SpringMVC详细运行流程图" class="headerlink" title="SpringMVC详细运行流程图"></a>SpringMVC详细运行流程图</h2><p><img src="/2022/05/16/springmvc/SpringMVC%E8%AF%A6%E7%BB%86%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="springmvc项目架构图"></p><h2 id="SpringMVC运行原理"><a href="#SpringMVC运行原理" class="headerlink" title="SpringMVC运行原理"></a>SpringMVC运行原理</h2><ul><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li><li>执行处理器(Controller，也叫后端控制器)。</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2022/04/20/spring/"/>
      <url>/2022/04/20/spring/</url>
      
        <content type="html"><![CDATA[<p>#Spring是什么? </p><ul><li><p> Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。<br>###主要由以下几个模块组成：</p></li><li><p>Spring Core：核心类库，提供IOC服务；</p></li><li><p>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</p></li><li><p>Spring AOP：AOP服务；</p></li><li><p>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</p></li><li><p>Spring ORM：对现有的ORM框架的支持；</p></li><li><p>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</p></li><li><p>Spring MVC：提供面向Web应用的Model-View-Controller实现。</p></li></ul><p>###Spring的优点？</p><ul><li><p>spring属于低侵入式设计，代码的污染极低；</p></li><li><p>spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；</p></li><li><p>Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。</p></li><li><p>spring对于主流的应用框架提供了集成支持。</p></li></ul><h3 id="Spring的AOP理解："><a href="#Spring的AOP理解：" class="headerlink" title="Spring的AOP理解："></a>Spring的AOP理解：</h3><ul><li>AOP，一般称为面向切面，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为“切面”（Aspect），<br>减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。可用于权限认证、日志、事务处理。</li><li>AOP实现的关键在于代理模式，AOP代理主要分为静态代理和动态代理。静态代理的代表为AspectJ；动态代理则以Spring AOP为代表。<pre class="line-numbers language-text" data-language="text"><code class="language-text">1.AspectJ是静态代理的增强，所谓静态代理，就是AOP框架会在编译阶段生成AOP代理类，因此也称为编译时增强，他会在编译阶段将AspectJ(切面)织入到Java字节码中，运行的时候就是增强之后的AOP对象。2.Spring AOP使用的动态代理，所谓的动态代理就是说AOP框架不会去修改字节码，而是每次运行时在内存中临时为方法生成一个AOP对象，这个AOP对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法。```             - Spring AOP中的动态代理主要有两种方式，JDK动态代理和CGLIB动态代理：```text①JDK动态代理只提供接口的代理，不支持类的代理。核心InvocationHandler接口和Proxy类，InvocationHandler 通过invoke()方法反射来调用目标类中的代码，动态地将横切逻辑和业务编织在一起；接着，Proxy利用 InvocationHandler动态创建一个符合某一接口的的实例,  生成目标类的代理对象。②如果代理类没有实现 InvocationHandler 接口，那么Spring AOP会选择使用CGLIB来动态代理目标类。CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态的生成指定类的一个子类对象，并覆盖其中特定方法并添加增强代码，从而实现AOP。CGLIB是通过继承的方式做的动态代理，因此如果某个类被标记为final，那么它是无法使用CGLIB做动态代理的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="Spring的IoC理解："><a href="#Spring的IoC理解：" class="headerlink" title="Spring的IoC理解："></a>Spring的IoC理解：</h3><ul><li>IOC就是控制反转，是指创建对象的控制权的转移，以前创建对象的主动权和时机是由自己把控的，而现在这种权力转移到Spring容器中，并由容器根据配置文件去创建实例和管理各个实例之间的依赖关系，对象与对象之间松散耦合，也利于功能的复用。DI依赖注入，和控制反转是同一个概念的不同角度的描述，即 应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。</li><li>最直观的表达就是，IOC让对象的创建不用去new了，可以由spring自动生产，使用java的反射机制，根据配置文件在运行时动态的去创建对象以及管理对象，并调用对象的方法的。</li><li>Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入。<pre><code class="text">IoC让相互协作的组件保持松散的耦合，而AOP编程允许你把遍布于应用各层的功能分离出来形成可重用的功能组件。</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单词总汇</title>
      <link href="/2022/04/20/dan-ci-zong-hui/"/>
      <url>/2022/04/20/dan-ci-zong-hui/</url>
      
        <content type="html"><![CDATA[<p>#单词总汇</p><h2 id="第一章：初始Mybatis框架"><a href="#第一章：初始Mybatis框架" class="headerlink" title="第一章：初始Mybatis框架"></a>第一章：初始Mybatis框架</h2><ul><li>1):  plain[无装饰的]</li><li>2):  relational[相关的]</li><li>3):  namespace[命名空间]</li><li>4):  configuration[布局]</li><li>5):  mapper[映射]</li><li>6):  builder[建立者]</li><li>7):  environment[生态环境]</li><li>8):  alias[别名]</li></ul><h2 id="第二章：SQL映射文件详解"><a href="#第二章：SQL映射文件详解" class="headerlink" title="第二章：SQL映射文件详解"></a>第二章：SQL映射文件详解</h2><ul><li>1):  association[关联]</li><li>2):  collection[收集]</li><li>3):  behavior[行为]</li><li>4):  partial[部分]</li><li>5):  eviction[收回]</li><li>6):  FIFO[先入先出]</li><li>7):  interval[无装饰的]</li></ul><h2 id="第三章：Mybatis框架动态SQL"><a href="#第三章：Mybatis框架动态SQL" class="headerlink" title="第三章：Mybatis框架动态SQL"></a>第三章：Mybatis框架动态SQL</h2><ul><li>1):  trim[修剪]</li><li>2):  suffix[后缀]</li><li>3):  prefixOverrides[前缀重写]</li><li>4):  suffixOverrides[后缀重写]</li><li>5):  foreach[循环]</li><li>6):  separator[分离器]</li></ul><h2 id="第一章：反射"><a href="#第一章：反射" class="headerlink" title="第一章：反射"></a>第一章：反射</h2><ul><li>1): reflection  [反射]</li><li>2): constructor  [构造函数]</li><li>3): field  [领域]</li><li>4): method  [方法]</li><li>5): simple  [结构单一]</li><li>6): modifier [修正]</li><li>7): declared  [公开声明]</li><li>8): declaring [说明]</li><li>9): member [成员]</li><li>10): instance [例子]</li><li>11): accessible [可达到的]</li><li>12): illegal  [非法的]</li><li>13): access [入口]</li><li>14): invoke [调用]</li><li>15): array [一系列]</li><li>16): component [构成的]</li><li>17): dimension [大小]</li><li>18): convertor [转化器]</li></ul><h2 id="第二章：XML"><a href="#第二章：XML" class="headerlink" title="第二章：XML"></a>第二章：XML</h2><ul><li>1): extensible [可展开的]</li><li>2): markup  [利润]</li><li>3): document [文档]</li><li>4): processing [处理]</li><li>5): parser  [解析器]</li><li>6): builder [建设者]</li><li>7): node  [节点]</li><li>8): element [元素]</li><li>9): attribute  [属性]</li><li>10): transformer  [变压器]</li><li>11): branch [分支]</li></ul><h2 id="第三章：设计模式"><a href="#第三章：设计模式" class="headerlink" title="第三章：设计模式"></a>第三章：设计模式</h2><ul><li>1): design [设计]</li><li>2): pattern  [模式]</li><li>3): reusable [可再用的]</li><li>4):4. factory  [工厂]</li><li>5): product [产品]</li><li>6): concrete [具体的]</li><li>7): subject [主题]</li><li>8): real [真实的]</li><li>9): proxy [代表权]</li><li>10): invocation [祈祷]</li><li>11): handler [处理者]</li><li>12): generation [产生]</li><li>13): library [图书馆]</li><li>14): interceptor [拦截器]</li><li>15): intercept [拦截]</li><li>16): enhancer [增强器]</li><li>17): callback [回收]</li></ul><h2 id="第四章：Redis"><a href="#第四章：Redis" class="headerlink" title="第四章：Redis"></a>第四章：Redis</h2><ul><li>1): cache 缓冲存储器</li><li>2): master-slave 主从</li><li>3): prefix 前缀</li><li>4): install 安装</li><li>5): memory 记忆</li><li>6): dump 倾倒</li><li>7): fork 分叉</li><li>8):  bind 约束</li><li>9): daemonize  守护进程</li><li>10): require 要求</li><li>11): auth 作家</li><li>12): nil  无</li><li>13): pattern 模式</li><li>14):  expire 期满</li><li>15): persist 坚持</li><li>16): quit  离开</li><li>17): verbose 冗长的</li><li>18): borrow 抵押</li></ul><h2 id="第五章：初始Spring"><a href="#第五章：初始Spring" class="headerlink" title="第五章：初始Spring"></a>第五章：初始Spring</h2><ul><li>1): inversion  倒置</li><li>2): control 控制</li><li>3): injection  注射</li><li>4): aspect-oriented 面向侧面</li><li>5): programming 规划</li><li>6): advice 劝告</li><li>7): aspect 方面</li><li>8): JoinPoint 连接点</li><li>9): alliance 联盟</li><li>10): pointcut 定点</li><li>11): weaving 编排</li><li>12): signature 签名</li><li>13): expression  表现</li><li>14): execution 实行</li></ul><h2 id="第六章：初始Spring"><a href="#第六章：初始Spring" class="headerlink" title="第六章：初始Spring"></a>第六章：初始Spring</h2><ol><li>constructor 构造器</li><li>local      地方的</li><li>proceed 前进</li><li>component  组成部分</li><li>autowire 自动驾驶</li><li>qualifier 合格者</li><li>resource 资源</li><li> annotation 注释</li></ol><h2 id="第七章：Spring深入"><a href="#第七章：Spring深入" class="headerlink" title="第七章：Spring深入"></a>第七章：Spring深入</h2><ol><li>location 位置</li><li>template 模板</li><li>support  支持</li><li>configurer 配置</li><li>transaction 交易</li><li>manager 处理者</li><li>propagation 传播</li><li>isolation 隔离</li><li>mandatory 强制的</li><li>nested 嵌套的</li><li>repeatable 可重复的</li><li>serializable 序列化</li><li>transactional 交易的</li><li>placeholder 占位符</li><li> singleton 单独</li><li> prototype 雏形</li><li>global 全球的</li><li>scope  处理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 单词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/04/08/redis/"/>
      <url>/2022/04/08/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h2><ul><li>Redis是一款内存高速缓存数据库。是一个key-value存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</li></ul><h2 id="redis有什么用？"><a href="#redis有什么用？" class="headerlink" title="redis有什么用？"></a>redis有什么用？</h2><ul><li>redis的作用：获取最新的n个数据；2、获取TOP N的数据；3、设置精准的抢购时间；4、实现计数器；5、去除重复值；6、利用set命令制作反垃圾系统；7、构建队列系统。</li></ul><p>1.获取最新的n个数据</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">现在你在和讯网黄金频道上班,项目经理让你负责每天在频道首页生成一张数据表,来展示1个月内的国际黄金的开盘和收盘价格.如果我们从mysql数据库中按时间排序取出,固然可以.但是你要考虑和讯网的并发量,和你排序时对资源的一个浪费程度.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这个时候我们选取redis的列表存取,就显得很有必要了,我们知道redis有一种队列(list)的数据结构,同时它还具备先进先出的特性.那这样的话,我去最新的1个月的数据不就信手拈来么.一个lrange命令即可简单地取出你想要的区间的值.</p><p>2.获取 TOP N的数据</p><ul><li>接下来的这个例子,看标题,感觉跟第1中应用差不多,其实还是有差别的.应用1我们是利用列表的先进先出的特性,按存取时间来取,接下来我们的这个示例,就是利用有序集合的特性来解决实际问题.<pre class="line-numbers language-text" data-language="text"><code class="language-text">现在你受雇于APPLESTORE,项目经理要求你在商店首页,展示下载量排行前30的APP.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>这个时候,你若能够想到我们redis学习过程中,给大家讲到的SortedSet有序集合,那就再好不过了.我们只需要将每个APP生成一个唯一的ID,将其作为集合中成员member,下载数目作为成员的score.那么当你将这个score插入到有序集合中时,redis就会按其进行大小排序,自然有个有序的集合就形成了.最终你要取前N或者后N的数据,就在于你自己了.</li></ul><p>4.轻松实现计数器</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">你目前就职的单位是中央全面深化改革领导小组技术顾问办公室,在过去如果全国人民一起选代表,既浪费人力又浪费财力.现在网络技术发展了,习近平组长交代由你牵头开发点赞选人大平台.接到这个项目,你是不是很犯难,13亿啊!可能同时集中在某个时间段,点赞,如此大的IO请求.硬盘数据库多少有些力不从心.哎,这个时候你要运用上我们的内存数据库系统了,redis中对key的增incre,减decr不正适合你的需求么.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>5.去除重复值</p><ul><li>去除重复值,听起来很熟悉,我们的MySQL不是有unique索引吗?哦,好吧,我要说的是我们redis中的对字符串的set命令更使用.<pre class="line-numbers language-text" data-language="text"><code class="language-text">你现在在下厨房平台,任职技术兼策划.你准备收集天下美食,苦于不知菜名.网络是有魔力的,人名群众的智慧是无穷的.你准备发动全国的网友们,为你提供菜名,同时你还不想让大家发出相同菜名.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>看到如此问题,你是否还能想到我们之前在学习redis的字符串类型时,说到的set命令,我们讲默认情况,不给其他参数时,如果我们的key不存在,则创建添加.如果key已经存在,则旧值覆盖新值.既然如此,key值存在,则覆盖.不正是我们需要的模型么?</li></ul><p>6.利用set命令制作反垃圾系统</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">上次你制作的统计菜名系统,领导会上先把你肯定了一番,然后义正言辞地说,小明啊,你这系统不太符合净网行动的要求啊,有些网友把一些带有明显淫秽色情的菜名都提交到了系统.还被展示出来投票,这不荒唐吗?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>吓的你一阵冷汗,这个时候你想到了在XX教育高性能架构班学习的同桌小胖.电话里小胖告诉你,当我们使用set命令对字符串进行操作时,给它一个NX参数,这样的话只有用户提交的key不存在时,才会对key进行操作.你去网上down一个敏感字汇字典,提前set入库,不就可以实现反垃圾了么.听完小胖的指导,紧张的你如释重负.</p><p>7.利用发布订阅的中的SUBSCRIBE和PUBLISH命令构建实时消息推送系统</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">费了老鼻子劲,你终于进入了新浪微博事业部.第二天组长找到正埋头苦干的你.小明,咱们微博也要搞个跟FB一样一样的关注功能,搞大V认证,大V一发消息,赶紧推送给关注的那群XX,让XX跟大V赶紧互动起来.以此来提高用户粘性.组长走后,”赶紧,推送”,这两个词在你的耳畔不时地回响.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>你又想到了小胖,小胖电话里告诉你.redis里有subscribe订阅和publish发布功能的.你挂了电话,去自学it网里一搜索,果不其然.一个subscribe可以订阅不同的用户模型,只要对应的模型有publish实现,订阅者即可实时收到,推送的消息.你虽然不是王大锤,但你也万万没想到redis竟然有如此功能</p><p>8.构建队列系统</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">忙完微博的事,正准备收拾东西去挤地铁的你.突然被组长叫住了.小明,你虽然完成了微博关注和推送的技术架构.但是这几天又有个新问题出现了.因为FB用不了,微博用户暴增.特别是认证大V的用户越来越多,就连门口烤红薯的大爷早上还拽着我说,给他整个大V吧,俺不差钱.老板为了缓解认证方面的压力,已经开始收费认证了,但是还是挡不住这群XX.赶上过节饭点,大V们几乎同时发微博,推送服务器有点压力.你把这个问题解决了,再走吧,晚点回去打车公司报销.然后打完卡他走了.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>“同时发微博”,”同时推送,服务器压力大”.你从电脑中找到了小胖之前发给你的那本redis自学笔记,笔记上说.我们可以将若干个需要执行的事件加入队列,然后按时间的顺序去逐个逐个的执行.这个时候你又想到了一个提高用户互动性的好办法.我能不能让粉丝数目多的大V的微博优先推送呢?毕竟粉丝基数大,影响大,总能搞出一个大新闻.既然这样,我直接使用有序队列不就行了.把一个个大V的微博推送事件ID存入有序队列,同时依据粉丝数给予权重(或说优先级).不就可以达到我们的需求了么.</p><p>9.缓存</p><ul><li>这一点大家应该很熟悉了,它可以像memcache一样充当缓存数据库.不过的它的数据类型比memcache多的多,应对场景自然要比memcache丰富的多.比较时髦的用法是,用其来缓存会话</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/04/06/she-ji-mo-shi/"/>
      <url>/2022/04/06/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><ul><li>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。</li><li>1995 年，GoF（Gang of Four，四人组/四人帮）合作出版了《设计模式：可复用面向对象软件的基础》一书，共收录了 23 种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。<br><img src="/2022/04/06/she-ji-mo-shi/02.jpg"></li><li>这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。<h5 id="当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择："><a href="#当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：" class="headerlink" title="当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择："></a>当然，软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择：</h5></li><li>对于简单的程序，可能写一个简单的算法要比引入某种设计模式更加容易；</li><li>但是对于大型项目开发或者框架设计，用设计模式来组织代码显然更好</li></ul><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><h5 id="总体来说设计模式分为三大类："><a href="#总体来说设计模式分为三大类：" class="headerlink" title="总体来说设计模式分为三大类："></a>总体来说设计模式分为三大类：</h5><ul><li>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li><li>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li><li>其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：<br><img src="/2022/04/06/she-ji-mo-shi/01.jpg"><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><h4 id="总原则：开闭原则（Open-Close-Principle）"><a href="#总原则：开闭原则（Open-Close-Principle）" class="headerlink" title="总原则：开闭原则（Open Close Principle）"></a>总原则：开闭原则（Open Close Principle）</h4><h6 id="开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等"><a href="#开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等" class="headerlink" title="开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等"></a>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等</h6><h4 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1.单一职责原则"></a>1.单一职责原则</h4><h6 id="不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分"><a href="#不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分" class="headerlink" title="不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分"></a>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分</h6><h4 id="2-里氏替换原则（Liskov-Substitution-Principle）"><a href="#2-里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="2.里氏替换原则（Liskov Substitution Principle）"></a>2.里氏替换原则（Liskov Substitution Principle）</h4><h6 id="里氏代换原则-Liskov-Substitution-Principle-LSP-面向对象设计的基本原则之一。-里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。-LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它"><a href="#里氏代换原则-Liskov-Substitution-Principle-LSP-面向对象设计的基本原则之一。-里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。-LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它" class="headerlink" title="里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它"></a>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它</h6><h4 id="3-Dependence-Inversion-Principle"><a href="#3-Dependence-Inversion-Principle" class="headerlink" title="3.(Dependence Inversion Principle)"></a>3.(Dependence Inversion Principle)</h4><h6 id="这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。"><a href="#这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。" class="headerlink" title="这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。"></a>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</h6><h4 id="4-接口隔离原则（Interface-Segregation-Principle）"><a href="#4-接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="4.接口隔离原则（Interface Segregation Principle）"></a>4.接口隔离原则（Interface Segregation Principle）</h4><h6 id="这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。"><a href="#这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。" class="headerlink" title="这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。"></a>这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</h6><h4 id="5-迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#5-迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="5.迪米特法则（最少知道原则）（Demeter Principle）"></a>5.迪米特法则（最少知道原则）（Demeter Principle）</h4><h6 id="就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。"><a href="#就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。" class="headerlink" title="就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。"></a>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</h6><h4 id="6-合成复用原则（Composite-Reuse-Principle）"><a href="#6-合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="6.合成复用原则（Composite Reuse Principle）"></a>6.合成复用原则（Composite Reuse Principle）</h4><h6 id="原则是尽量首先使用合成-聚合的方式，而不是使用继承。"><a href="#原则是尽量首先使用合成-聚合的方式，而不是使用继承。" class="headerlink" title="原则是尽量首先使用合成/聚合的方式，而不是使用继承。"></a>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</h6></li></ul><h3 id="Java的23中设计模式图"><a href="#Java的23中设计模式图" class="headerlink" title="Java的23中设计模式图"></a>Java的23中设计模式图</h3><h5 id="简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。"><a href="#简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。" class="headerlink" title="简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。"></a>简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。</h5><h5 id="01-简单工厂模式"><a href="#01-简单工厂模式" class="headerlink" title="01.简单工厂模式"></a>01.简单工厂模式</h5><p> 就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建<br><img src="/2022/04/06/she-ji-mo-shi/03.png"></p><h5 id="02-多个方法"><a href="#02-多个方法" class="headerlink" title="02.多个方法"></a>02.多个方法</h5><p>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：<br><img src="/2022/04/06/she-ji-mo-shi/04.jpg"></p><h6 id="1-工厂方法模式（Factory-Method）"><a href="#1-工厂方法模式（Factory-Method）" class="headerlink" title="1.工厂方法模式（Factory Method）"></a>1.工厂方法模式（Factory Method）</h6><p>简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。<br><img src="/2022/04/06/she-ji-mo-shi/05.jpg"></p><h5 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2.抽象工厂模式"></a>2.抽象工厂模式</h5><p>工厂方法模式和抽象工厂模式不好分清楚，他们的区别如下：</p><pre class="line-numbers language-none"><code class="language-none">工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。   一个抽象工厂类，可以派生出多个具体工厂类。   每个具体工厂类只能创建一个具体产品类的实例。抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。   一个抽象工厂类，可以派生出多个具体工厂类。   每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。       区别：工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。   工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 "一种" 产品，他的着重点在于"怎么创建"，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。 抽象工厂需要创建一些列产品，着重点在于"创建哪些"产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-单例模式（Singleton）"><a href="#3-单例模式（Singleton）" class="headerlink" title="3.单例模式（Singleton）"></a>3.单例模式（Singleton）</h5><p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p><ul><li>某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</li><li>省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</li><li>有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</li></ul><h5 id="4-代理模式（Proxy）"><a href="#4-代理模式（Proxy）" class="headerlink" title="4.代理模式（Proxy）"></a>4.代理模式（Proxy）</h5><p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：<br><img src="/2022/04/06/she-ji-mo-shi/06.jpg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML</title>
      <link href="/2022/04/01/xml/"/>
      <url>/2022/04/01/xml/</url>
      
        <content type="html"><![CDATA[<p>##XML简介</p><ul><li>XML 被设计用来传输和存储数据</li><li>HTML 被设计用来显示数据<h2 id="什么是XML？"><a href="#什么是XML？" class="headerlink" title="什么是XML？"></a>什么是XML？</h2></li><li>XML 指可扩展标记语言（EXtensible Markup Language）。</li><li>XML 是一种很像HTML的标记语言。</li><li>XML 的设计宗旨是传输数据，而不是显示数据。</li><li>XML 标签没有被预定义。您需要自行定义标签。</li><li>XML 被设计为具有自我描述性。</li><li>XML 是 W3C 的推荐标准。<h2 id="XML不是对HTML的替代"><a href="#XML不是对HTML的替代" class="headerlink" title="XML不是对HTML的替代"></a>XML不是对HTML的替代</h2></li><li>XML是对HTML的补充</li><li>XML 不会替代 HTML，理解这一点很重要在大多数Web 应用程序中，XML用于传输数据，而HTML用于格式化并显示数据。</li><li>对XML最好的描述是：XML是独立于软件和硬件的信息传输工具。</li></ul><h2 id="XML用途"><a href="#XML用途" class="headerlink" title="XML用途"></a>XML用途</h2><ul><li>XML 应用于 Web 开发的许多方面，常用于简化数据的存储和共享。<h2 id="XML把数据从HTML分离"><a href="#XML把数据从HTML分离" class="headerlink" title="XML把数据从HTML分离"></a>XML把数据从HTML分离</h2></li><li>如果您需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。<br>通过 XML，数据能够存储在独立的 XML 文件中。这样您就可以专注于使用 HTML/CSS 进行显示和布局，并确保修改底层数据不再需要对 HTML 进行任何的改变。<br>通过使用几行 JavaScript 代码，您就可以读取一个外部 XML 文件，并更新您的网页的数据内容。</li></ul><h2 id="XML简化数据共享"><a href="#XML简化数据共享" class="headerlink" title="XML简化数据共享"></a>XML简化数据共享</h2><ul><li>在真实的世界中，计算机系统和数据使用不兼容的格式来存储数据。<br>  XML 数据以纯文本格式进行存储，因此提供了一种独立于软件和硬件的数据存储方法。<br>  这让创建不同应用程序可以共享的数据变得更加容易。</li></ul><h2 id="XML语法规则"><a href="#XML语法规则" class="headerlink" title="XML语法规则"></a>XML语法规则</h2><ul><li>XML的语法规则很简单且很有逻辑这些规则很容易学习也很容易使用。</li><li>所有的XML元素都必须有一个关闭标签</li><li>XML标签对大小写敏感</li><li>XML必须正确嵌套</li><li>XML属性值必须加引号<br><img src="/2022/04/01/xml/xml.png%22"></li></ul><h2 id="XML文档必须有根元素"><a href="#XML文档必须有根元素" class="headerlink" title="XML文档必须有根元素"></a>XML文档必须有根元素</h2><ul><li>XML 必须包含根元素它是所有其他元素的父元素比如以下实例中root就是根元素：<pre class="line-numbers language-none"><code class="language-none">&lt;root&gt;  &lt;child&gt;    &lt;subchild&gt;.....&lt;/subchild&gt;  &lt;/child&gt;&lt;/root&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="XML声明"><a href="#XML声明" class="headerlink" title="XML声明"></a>XML声明</h2><ul><li>XML 声明文件的可选部分，如果存在需要放在文档的第一行，如下所示：<pre class="line-numbers language-none"><code class="language-none">&lt;?xml version="1.0" encoding="utf-8"?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> XML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax</title>
      <link href="/2022/03/30/ajax/"/>
      <url>/2022/03/30/ajax/</url>
      
        <content type="html"><![CDATA[<p>#ajax</p><h2 id="什么是ajax"><a href="#什么是ajax" class="headerlink" title="什么是ajax"></a>什么是ajax</h2><ul><li>JQUery封装了一个函数，称之为$.ajax,通过对象调用ajax()函数，<br>可以异步加载相关的请求。依靠的是javascript提供的一个对象XHP(XmlHttpRequest)<br>,封装了这个对象。</li><li>是客户端（浏览器）与服务器进行异步通信的编程模式,能让浏览器局部刷新变化数据，采用异步方式的工作机制。<br>AJAX异步的js的XML</li><li>AJAX采用异步方式与服务器进行交互，可以实现局部刷新，而无需全网页的刷新，减轻浏览器的压力，增强用户的体验。<h2 id="ajax-的使用方式-需要传递一个方法体作为方法的参数来使用，一对大括号称之为方法体。语法结构："><a href="#ajax-的使用方式-需要传递一个方法体作为方法的参数来使用，一对大括号称之为方法体。语法结构：" class="headerlink" title="ajax()的使用方式 需要传递一个方法体作为方法的参数来使用，一对大括号称之为方法体。语法结构："></a>ajax()的使用方式 需要传递一个方法体作为方法的参数来使用，一对大括号称之为方法体。语法结构：</h2><pre class="line-numbers language-js" data-language="js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token literal-property property">url</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token literal-property property">type</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token literal-property property">data</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token literal-property property">dataType</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token function-variable function">success</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function-variable function">error</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>ajax()函数的参数的含义：</li></ul><table><thead><tr><th>参数</th><th align="right">功能描述</th></tr></thead><tbody><tr><td>url</td><td align="right">表示请求的地址(url地址) 不能包含参数列表部分</td></tr><tr><td>type</td><td align="right">请求的类型(GET和POST请求的类型等…)</td></tr><tr><td>data</td><td align="right">向请求的url地址提交的数据。例如：data:”username=lt&amp;pwd=123456”</td></tr><tr><td>dataType</td><td align="right">提交的数据类型。数据的类型一般指定为json类型</td></tr><tr><td>success</td><td align="right">当服务器正常响应客户端时，会自动调用success参数的方法，并且将服务器的数据返回的数据以参数的形式传递给这个方法的参数上</td></tr><tr><td>error</td><td align="right">当服务器未正常响应客户端时，会自动调用error参数的方法，并且将服务器的数据返回的数据以参数的形式传递给这个方法的参数上</td></tr><tr><td>————————————————</td><td align="right"></td></tr></tbody></table><ul><li>js代码可以独立声明在js的文件里或者声明在script标签中</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AJAX </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2022/03/29/mybatis/"/>
      <url>/2022/03/29/mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是Mybatis"><a href="#什么是Mybatis" class="headerlink" title="什么是Mybatis"></a>什么是Mybatis</h1><ul><li>ORM (Object-Relationship-Mapper):是对象关系映射的意思,它是一种思想，是指将数据库的每一行数据用对象的形式展现出来.</li><li>JPA (Java-Persistence-API):是java持久化的意思，它是JavaEE关于ORM思想的一套标准接口，仅仅是一套接口，不是具体的实现。    </li><li>MyBatis 是一个实现了JPA规范的用来连接数据库并对其进行CRUD操作的开源框框<br>(就和传统的JDBC一样，就是个连接数据库的东西)，其实，它底层就是一个JDBC的封装的组件。MyBatis<br>前身是Ibatis,Ibatis创建于2002年最初为Apache下面的一个开源的项目，2010迁移到<br>google code下面并改名为MyBatis。Mybatis虽然实现了JPA但是它并不是一个完完全全的<br>ORM组件，而是一个基于SQL开发的半ORM组件。</li></ul><h2 id="MyBatis的优点和缺点"><a href="#MyBatis的优点和缺点" class="headerlink" title="MyBatis的优点和缺点"></a>MyBatis的优点和缺点</h2><h3 id="MyBatis的优点："><a href="#MyBatis的优点：" class="headerlink" title="MyBatis的优点："></a>MyBatis的优点：</h3><ul><li>1.与JDBC相比，减少了50%以上的代码量。</li><li>2.MyBatis是最简单的持久化框架，小巧并且简单易学。</li><li>3.MyBatis灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL可以写在XML里（还可以以注解方式写到Java代码中），从程序代码中彻底分离，降低耦合度，便于统一管理和优化，可重用。</li><li>4.提供XML标签，支持编写动态SQL语句（XML中使用 if, else 等）。</li><li>5.提供映射标签，支持对象与数据库的ORM字段关系映射（可以在XML中配置映射关系，也可以使用注解配置映射关系）。<h3 id="MyBatis的缺点："><a href="#MyBatis的缺点：" class="headerlink" title="MyBatis的缺点："></a>MyBatis的缺点：</h3></li><li>1.SQL语句的编写工作量较大，尤其是字段多、关联表多时，更是如此，对开发人员编写SQL语句的功底有一定要求。</li><li>2.SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li><li>3.与JDBC相比，增加了调试代码和查错的难度（使用了ORM需要额外花费时间学习ORM的框架，调试错误比JDBC难很多）。封装程度越高，查错越难。</li><li>4.JDBC可以单步调试，MyBatis不能单步调试。</li></ul><h2 id="MyBatis动态sql是做什么的？"><a href="#MyBatis动态sql是做什么的？" class="headerlink" title="MyBatis动态sql是做什么的？"></a>MyBatis动态sql是做什么的？</h2><ul><li>1.MyBatis动态sql可以让我们在XML映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。</li><li>2.MyBatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind.</li><li>3.其执行原理为，使用OGNL从sql参数对象种计算表达式的值，根据表达式的值动态拼接sql，来完成动态sql的功能。<br><img src="/2022/03/29/mybatis/mybais1.png"><h2 id="MyBatis的配置文件"><a href="#MyBatis的配置文件" class="headerlink" title="MyBatis的配置文件"></a>MyBatis的配置文件</h2><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;!--    引入包含数据库连接参数的database.properties文件--&gt;    &lt;properties resource="database.properties"&gt;&lt;/properties&gt;&lt;!--    1.设置MyBatis框架的运行时行为--&gt;    &lt;settings&gt;&lt;!--        使用Log4j作为MyBatis框架的日志实现--&gt;        &lt;setting name="logImpl" value="LOG4J"/&gt;&lt;!--        设置自动映射行为--&gt;        &lt;setting name="autoMappingBehavior" value="FULL"/&gt;&lt;!--        禁用自动映射--&gt;&lt;!--        &lt;setting name="autoMappingBehavior" value="NONE"/&gt;--&gt;    &lt;/settings&gt;&lt;!--    为实体类配置别名--&gt;    &lt;typeAliases&gt;        &lt;package name="cn.cvs.popj"/&gt;&lt;!--        &lt;typeAlias alias="sysuer" type="cn.cvs.popj.SysUser"&gt;&lt;/typeAlias&gt;--&gt;&lt;!--        &lt;typeAlias alias="supplier" type="cn.cvs.popj.SysUser"&gt;&lt;/typeAlias&gt;--&gt;    &lt;/typeAliases&gt;&lt;!--    2.配置MyBatis框架的运行环境--&gt;    &lt;environments default="development"&gt;        &lt;environment id="development"&gt;&lt;!--            配置事务管理器,采用JDBC事务,由应用自行管理事务--&gt;            &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;&lt;!--            配置数据源,POOLED:MyBatis提供的数据源,JNDI:JNDI数据源--&gt;            &lt;dataSource type="POOLED"&gt;                &lt;!--            使用${}引用定义的参数,此处参数来源于database.properties文件--&gt;                &lt;property name="driver" value="${jdbc.driver}"/&gt;                &lt;property name="url" value="${jdbc.url}"/&gt;                &lt;property name="username" value="${jdbc.username}"/&gt;                &lt;property name="password" value="${jdbc.password}"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;!--    3.配置需要引用的SQL映射文件的位置--&gt;    &lt;mappers&gt;        &lt;package name="cn/cvs/dao/sysUser"/&gt;&lt;!--        &lt;mapper resource="cn/cvs/dao/sysUser/SysUserMapper.xml"&gt;&lt;/mapper&gt;--&gt;    &lt;/mappers&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2022/03/29/fan-she/"/>
      <url>/2022/03/29/fan-she/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是java反射"><a href="#什么是java反射" class="headerlink" title="什么是java反射"></a>什么是java反射</h2><ul><li>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，<br>都能调用它的任意一个方法，在java中，只要给定类的名字，就可以通过反射机制来获取类的所以信息<br>。这种动态获取的信息以及动态调用的方法的功能称为java语言的反射机制。<br>从而使Java具有动态语言的特性，增强了程序的灵活性和可移植性</li></ul><h2 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h2><ul><li>在运行时判断任意一个对象所属的类型。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法，甚至可以调用private方法。</li></ul><h2 id="Java反射机制API"><a href="#Java反射机制API" class="headerlink" title="Java反射机制API"></a>Java反射机制API</h2><ul><li>Class类：代表一个类。</li><li>Filed类：代表类的成员变量。</li><li>Method类：代表类的方法。</li><li>Constructor类：代表类的构造方法。</li><li>Array类：提供了动态创建数组及访问数组元素的静态方法。该类中的所有方法都是静态的。</li></ul><h2 id="反射可访问的常用信息"><a href="#反射可访问的常用信息" class="headerlink" title="反射可访问的常用信息"></a>反射可访问的常用信息</h2><p><img src="/2022/03/29/fan-she/fanshe.PNG" alt="反射可访问的常用信息"></p><h2 id="反射机制的优点"><a href="#反射机制的优点" class="headerlink" title="反射机制的优点"></a>反射机制的优点</h2><ul><li>首先，反射机制极大的提高了程序的灵活性和扩展性，降低模块的耦合性，提高自身的适应能力。<br>其次，通过反射机制可以让程序创建和控制任何类的对象，无需提前硬编码目标类。<br>再次，使用反射机制能够在运行时构造一个类的对象、判断一个类所具有的成员变量和方法、调用一个对象的方法。<br>最后，反射机制是构建框架技术的基础所在，使用反射可以避免将代码写死在框架中。<br>java的反射机制就是增加程序的灵活性，避免将程序写死到代码里。<br>例如： 实例化一个 person()对象， 不使用反射， new person(); 如果想变成 实例化 其他类， 那么必须修改源代码，并重新编译。<pre class="line-numbers language-none"><code class="language-none">使用反射： class.forName("com.xxx.Person").newInstance()； 而且这个类描述可以写到配置文件中，如 **.xml, 这样如果想实例化其他类，只要修改配置文件的"类描述"就可以了，不需要重新修改代码并编译。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="反射机制的缺点"><a href="#反射机制的缺点" class="headerlink" title="反射机制的缺点"></a>反射机制的缺点</h2><h3 id="尽管反射机制带来了极大的灵活性及方便性，但反射也有缺点。反射机制的功能非常强大，但不能滥用。在能不使用反射完成时，尽量不要使用，原因有以下几点："><a href="#尽管反射机制带来了极大的灵活性及方便性，但反射也有缺点。反射机制的功能非常强大，但不能滥用。在能不使用反射完成时，尽量不要使用，原因有以下几点：" class="headerlink" title="尽管反射机制带来了极大的灵活性及方便性，但反射也有缺点。反射机制的功能非常强大，但不能滥用。在能不使用反射完成时，尽量不要使用，原因有以下几点："></a>尽管反射机制带来了极大的灵活性及方便性，但反射也有缺点。反射机制的功能非常强大，但不能滥用。在能不使用反射完成时，尽量不要使用，原因有以下几点：</h3><ul><li>1、性能问题。<br>Java反射机制中包含了一些动态类型，所以Java虚拟机不能够对这些动态代码进行优化。因此，反射操作的效率要比正常操作效率低很多。我们应该避免在对性能要求很高的程序或经常被执行的代码中使用反射。而且，如何使用反射决定了性能的高低。如果它作为程序中较少运行的部分，性能将不会成为一个问题。</li><li>2、安全限制。<br>使用反射通常需要程序的运行没有安全方面的限制。如果一个程序对安全性提出要求，则最好不要使用反射。</li><li>3、程序健壮性。<br>反射允许代码执行一些通常不被允许的操作，所以使用反射有可能会导致意想不到的后果。反射代码破坏了Java程序结构的抽象性，所以当程序运行的平台发生变化的时候，由于抽象的逻辑结构不能被识别，代码产生的效果与之前会产生差异。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
